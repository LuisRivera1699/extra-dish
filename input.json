{
    "language": "Solidity",
    "sources": {
        "contracts/ExtraDish.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nstruct Dish {\n    string name;\n    string description;\n    uint price;\n    string pickUpAddress;\n    string image;\n    address payable owner;\n    uint status;\n    uint id;\n    address payable requester;\n    string requestDescription;\n    string rateDescription;\n}\n\ncontract ExtraDish {\n\n    uint public dishCounter;\n    uint public requestCounter;\n    uint public SERVICE_FEE = 3;\n    mapping (uint => Dish) public dishId;\n    mapping (address => uint[]) public addressDishes;\n    address CEO_ADDRESS = 0x93a758c63CD7B15C8def570378E017ea0a2d7fd2;\n\n    constructor() {}\n\n    function createDish(\n        string memory name,\n        string memory description,\n        uint price,\n        string memory pickUpAddress,\n        string memory image\n    ) external {\n        Dish memory auxDish = dishId[dishCounter];\n        auxDish.name = name;\n        auxDish.description = description;\n        auxDish.price = price;\n        auxDish.pickUpAddress = pickUpAddress;\n        auxDish.image = image;\n        auxDish.owner = payable(msg.sender);\n        auxDish.status = 1;\n        auxDish.id = dishCounter;\n\n        dishId[dishCounter] = auxDish;\n        addressDishes[msg.sender].push(dishCounter);\n        dishCounter++;\n    }\n\n    function getMyDishes() external view returns (Dish[] memory) {\n        uint[] memory myDishIds = addressDishes[msg.sender];\n        Dish[] memory myDishes = new Dish[](myDishIds.length);\n\n        for (uint i = 0; i < myDishIds.length; i++) {\n            myDishes[i] = dishId[myDishIds[i]];\n        }\n\n        return myDishes;\n    }\n\n    function getPendingDishes() external view returns (Dish[] memory) {\n        uint matchingCount = 0;\n\n        for (uint i = 0; i < dishCounter; i++) {\n            if (dishId[i].status == 1 && dishId[i].owner != msg.sender) {\n                matchingCount++;\n            }\n        }\n\n        Dish[] memory matchingDishes = new Dish[](matchingCount);\n        uint index = 0;\n\n        for (uint i = 0; i < dishCounter; i++) {\n            if (dishId[i].status == 1 && dishId[i].owner != msg.sender) {\n                matchingDishes[index] = dishId[i];\n                index++;\n            }\n        }\n\n        return matchingDishes;\n    }\n\n    function requestDish(uint id, string memory requestDescription) external payable {\n        Dish memory auxDish = dishId[id];\n        require(msg.value == auxDish.price);\n\n        auxDish.requester = payable(msg.sender);\n        auxDish.status = 2;\n        auxDish.requestDescription = requestDescription;\n\n        dishId[id] = auxDish;\n    }\n\n    function getMyRequestsAsASeller() external view returns (Dish[] memory){\n        uint[] memory myDishIds = addressDishes[msg.sender];\n\n        uint matchingCount = 0;\n\n        for (uint i = 0; i < myDishIds.length; i++) {\n            if (dishId[myDishIds[i]].status == 2 || dishId[myDishIds[i]].status == 3 || dishId[i].status == 4) {\n                matchingCount++;\n            }\n        }\n\n        Dish[] memory matchingDishes = new Dish[](matchingCount);\n        uint index = 0;\n\n        for (uint i = 0; i < myDishIds.length; i++) {\n            if (dishId[myDishIds[i]].status == 2 || dishId[myDishIds[i]].status == 3 || dishId[i].status == 4) {\n                matchingDishes[index] = dishId[myDishIds[i]];\n                index++;\n            }\n        }\n\n        return matchingDishes;\n    }\n\n    function getMyRequestsAsABuyer() external view returns (Dish[] memory){\n        uint matchingCount = 0;\n\n        for (uint i = 0; i < dishCounter; i++) {\n            bool statusMatches = dishId[i].status == 2 || dishId[i].status == 3 || dishId[i].status == 4;\n            if (statusMatches && dishId[i].requester == msg.sender) {\n                matchingCount++;\n            }\n        }\n\n        Dish[] memory matchingDishes = new Dish[](matchingCount);\n        uint index = 0;\n\n        for (uint i = 0; i < dishCounter; i++) {\n            bool statusMatches = dishId[i].status == 2 || dishId[i].status == 3 || dishId[i].status == 4;\n            if (statusMatches && dishId[i].requester == msg.sender) {\n                matchingDishes[index] = dishId[i];\n                index++;\n            }\n        }\n\n        return matchingDishes;\n    }\n\n    function cancelRequest(uint id) external {\n        Dish memory auxDish = dishId[id];\n        require(auxDish.owner == msg.sender || auxDish.requester == msg.sender);\n        require(auxDish.status == 2);\n        require(auxDish.requester != address(0));\n\n        if (auxDish.owner == msg.sender) {\n            payable(auxDish.requester).transfer(auxDish.price);\n        }\n\n        if (auxDish.requester == msg.sender) {\n            uint fee = auxDish.price * SERVICE_FEE / 100;\n            payable(CEO_ADDRESS).transfer(fee);\n            payable(auxDish.requester).transfer(auxDish.price - fee);\n        }\n\n        auxDish.requestDescription = \"\";\n        auxDish.requester = payable(address(0));\n        auxDish.status = 1;\n\n        dishId[id] = auxDish;\n    }\n\n    function received(uint id) external {\n        Dish memory auxDish = dishId[id];\n        require(auxDish.requester == msg.sender);\n        require(auxDish.status == 2);\n\n        auxDish.status = 3;\n\n        uint fee = auxDish.price * SERVICE_FEE / 100;\n        payable(CEO_ADDRESS).transfer(fee);\n        payable(auxDish.owner).transfer(auxDish.price - fee);\n\n        dishId[id] = auxDish;\n    }\n\n    function rateDish(uint id, string memory rateDescription) external {\n        Dish memory auxDish = dishId[id];\n        require(auxDish.requester == msg.sender);\n        require(auxDish.status == 3);\n\n        auxDish.rateDescription = rateDescription;\n        auxDish.status = 4;\n\n        dishId[id] = auxDish;\n    }\n\n    function getAddressRates(address owner) external view returns(Dish[] memory) {\n        uint matchingCount = 0;\n\n        uint[] memory ownerDishes = addressDishes[owner];\n\n        for (uint i = 0; i < ownerDishes.length; i++) {\n            if (bytes(dishId[ownerDishes[i]].rateDescription).length > 0) {\n                matchingCount++;\n            }\n        }\n\n        Dish[] memory matchingDishes = new Dish[](matchingCount);\n        uint index = 0;\n\n        for (uint i = 0; i < ownerDishes.length; i++) {\n            if (bytes(dishId[ownerDishes[i]].rateDescription).length > 0) {\n                matchingDishes[index] = dishId[i];\n                index++;\n            }\n        }\n\n        return matchingDishes;\n    }\n\n}"
        }
    },
    "settings": {
        "optimizer": {
            "enabled": false,
            "runs": 200
        },
        "outputSelection": {
            "*": {
                "": [
                    "ast"
                ],
                "*": [
                    "abi",
                    "metadata",
                    "devdoc",
                    "userdoc",
                    "storageLayout",
                    "evm.legacyAssembly",
                    "evm.bytecode",
                    "evm.deployedBytecode",
                    "evm.methodIdentifiers",
                    "evm.gasEstimates",
                    "evm.assembly"
                ]
            }
        },
        "remappings": []
    }
}